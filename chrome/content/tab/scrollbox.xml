<?xml version="1.0"?>

<bindings id="tabmix-arrowscrollboxBindings"
   xmlns="http://www.mozilla.org/xbl"
   xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
   xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="tabmix-right-scrollBox"
           extends="chrome://global/content/bindings/scrollbox.xml#scrollbox-base">
    <content _side="right">
        <xul:toolbarbutton class="scrollbutton-up"
                           xbl:inherits="orient"
                           oncontextmenu="TabmixAllTabs.createScrollButtonTabsList(event, 'left');"
                           anonid="scrollbutton-up-right"
                           onclick="gBrowser.tabContainer.mTabstrip._distanceScroll(event);"
                           onmousedown="if (event.button == 0) gBrowser.tabContainer.mTabstrip._startScroll(-1);"
                           onmouseup="if (event.button == 0) gBrowser.tabContainer.mTabstrip._stopScroll();"
                           onmouseover="gBrowser.tabContainer.mTabstrip._continueScroll(-1);"
                           onmouseout="gBrowser.tabContainer.mTabstrip._pauseScroll();"/>
        <xul:toolbarbutton class="scrollbutton-down"
                           xbl:inherits="orient"
                           oncontextmenu="TabmixAllTabs.createScrollButtonTabsList(event, 'right');"
                           anonid="scrollbutton-down-right"
                           onclick="gBrowser.tabContainer.mTabstrip._distanceScroll(event);"
                           onmousedown="if (event.button == 0) gBrowser.tabContainer.mTabstrip._startScroll(1);"
                           onmouseup="if (event.button == 0) gBrowser.tabContainer.mTabstrip._stopScroll();"
                           onmouseover="gBrowser.tabContainer.mTabstrip._continueScroll(1);"
                           onmouseout="gBrowser.tabContainer.mTabstrip._pauseScroll();"/>
    </content>
    <implementation>
      <field name="_scrollButtonUp">
        document.getAnonymousElementByAttribute(this, "anonid", "scrollbutton-up-right");
      </field>

      <field name="_scrollButtonDown">
        document.getAnonymousElementByAttribute(this, "anonid", "scrollbutton-down-right");
      </field>

      <constructor>
        if (Tabmix.isVersion(170)) {
          this._scrollButtonUp.removeAttribute("onmouseover");
          this._scrollButtonDown.removeAttribute("onmouseover");
        }
      </constructor>

      <method name="finishScroll">
        <parameter name="aEvent"/>
        <body><![CDATA[
          let tabBar = gBrowser.tabContainer;
          if (!tabBar.useTabmixDnD(aEvent))
            return;
          TMP_tabDNDObserver.clearDragmark();
          let index, target = aEvent.originalTarget.getAttribute("anonid");
          if (target == "scrollbutton-up-right")
            index = -1;
          else if (target == "scrollbutton-down-right")
            index = 1;
          if (index) {
            let tabstrip = gBrowser.tabContainer.mTabstrip;
            let amountToScroll, distanceToRow = tabstrip._distanceToRow(0);
            if (distanceToRow * index < 0)
              amountToScroll = tabstrip.singleRowHeight * index + distanceToRow;
            else
              amountToScroll = distanceToRow;
            tabstrip.scrollByPixels(amountToScroll);
          }
        ]]></body>
      </method>
    </implementation>

    <handlers>
      <handler event="dragover"><![CDATA[
        let tabBar = gBrowser.tabContainer;
        if (tabBar.useTabmixDnD(aEvent))
          TMP_tabDNDObserver.onDragOver(event);
      ]]></handler>

      <handler event="drop"><![CDATA[
        this.finishScroll(event);
      ]]></handler>

      <handler event="dragexit"><![CDATA[
        this.finishScroll(event);
      ]]></handler>
    </handlers>

  </binding>

  <binding id="tabmix-arrowscrollbox-clicktoscroll"
                  extends="chrome://global/content/bindings/scrollbox.xml#arrowscrollbox-clicktoscroll">
    <implementation>

      <field name="blockUnderflow">false</field>
      <field name="blockOverflow">false</field>

      <field name="_scrollButtonUpLeft">
        document.getAnonymousElementByAttribute(this, "anonid", "scrollbutton-up");
      </field>

      <field name="_scrollButtonDownLeft">
        document.getAnonymousElementByAttribute(this, "anonid", "scrollbutton-down");
      </field>

      <!-- we replace tabbrowser.xml "tabbrowser-arrowscrollbox" binding with this one
           Override scrollbox.xml method, since our scrollbox's children are
           inherited from the binding parent -->
      <method name="_getScrollableElements">
        <body><![CDATA[
          return Array.filter(document.getBindingParent(this).childNodes,
                              this._canScrollToElement, this);
        ]]></body>
      </method>

      <method name="_canScrollToElement">
        <parameter name="tab"/>
        <body><![CDATA[
          return !tab.pinned && !tab.hidden;
        ]]></body>
      </method>

      <constructor>
        <![CDATA[
          if (this.tabmix_inited)
            return;

          this.tabmix_inited = true;

          this.offsetAmountToScroll = Tabmix.prefs.getBoolPref("offsetAmountToScroll");
          this.offsetRatio = document.getBindingParent(this).closeButtonsEnabled ? 0.70 : 0.50;
          Tabmix.newCode(null, this.ensureElementIsVisible)._replace(
            'var amountToScroll',
            '$&, offset = true'
          )._replace(
            'STOP_DISTANCE = 15;',
            'STOP_DISTANCE = TabmixTabbar.isMultiRow ? 3 : 15;'
          )._replace(
            'amountToScroll = this._isScrolling * STOP_DISTANCE;',
            '{$& \
             offset = false;}'
          )._replace(
            'this._stopSmoothScroll();',
            '$& \
             if (offset) {\
               amountToScroll += this.getOffsetAmountToScroll(element, amountToScroll);}'
          ).toCode(false, this, "ensureElementIsVisible");

          Tabmix.newCode(null, this._distanceScroll)._replace(
            '{',
            '{ if (aEvent.button && aEvent.button == 2) return;'
          ).toCode(false, this, "_distanceScroll");

          Tabmix.newCode(null, this._smoothScrollByPixels)._replace(
            '{',
            '$& \
             amountToScroll = this._distanceToRow(amountToScroll);'
          ).toCode(false, this, "_smoothScrollByPixels");

          if (Tabmix.isVersion(70)) {
            // we divide scrollDelta by the ratio between tab width and tab height
            let fnName = Tabmix.isVersion(110) ? "sample" : "handleEvent";
            Tabmix.newCode(null, this._arrowScrollAnim[fnName])._replace(
              '0.5 * timePassed * scrollIndex',
              'TabmixTabbar.isMultiRow ? Math.ceil(0.5 * timePassed / this.scrollbox._verticalAnimation) * scrollIndex : $&'
            ).toCode(false, this._arrowScrollAnim, fnName);
          }
          else {
            Tabmix.newCode(null, this.notify)._replace(
              'this.scrollByPixels(25 * this._scrollIndex);',
              'this.scrollByPixels((TabmixTabbar.isMultiRow ? this._smoothVerticalScroll : 25) * this._scrollIndex, true);'
            ).toCode(false, this, "notify");
          }

          // the ratio between tab width and tab height is approximately 6
          // we multiply here the distance to get same animation effect.
          Tabmix.newCode(null, this._scrollAnim.start)._replace(
            'Math.abs(distance)',
            'Math.abs(distance * (TabmixTabbar.isMultiRow ? this.scrollbox._verticalAnimation : 1))'
          ).toCode(false, this._scrollAnim, "start");

          this._scrollButtonUpLeft.addEventListener("contextmenu", this._createScrollButtonContextMenu, true);
          this._scrollButtonDownLeft.addEventListener("contextmenu", this._createScrollButtonContextMenu, true);

          Services.prefs.addObserver("toolkit.scrollbox.", this.tabmixPrefObserver, false);
          this.firstVisible =  {tab: null, x: 0, y: 0};
        ]]>
      </constructor>

      <destructor>
        <![CDATA[
          this._scrollButtonUpLeft.removeEventListener("oncontextmenu", this._createScrollButtonContextMenu, true);
          this._scrollButtonDownLeft.removeEventListener("oncontextmenu", this._createScrollButtonContextMenu, true);

          Services.prefs.removeObserver("toolkit.scrollbox.", this.tabmixPrefObserver);
        ]]>
      </destructor>

      <method name="_createScrollButtonContextMenu">
        <parameter name="aEvent"/>
        <body><![CDATA[
          let side = aEvent.target.className == "scrollbutton-up" ? "left" : "right";
          TabmixAllTabs.createScrollButtonTabsList(aEvent, side);
        ]]></body>
      </method>

      <field name="tabmixPrefObserver"><![CDATA[({
        scrollbox: this,
        observe: function (subject, topic, data) {
          switch (data) {
            case "toolkit.scrollbox.clickToScroll.scrollDelay":
              this.scrollbox._scrollDelay = Services.prefs.getIntPref(data);
              break;
            case "toolkit.scrollbox.smoothScroll":
              this.scrollbox.smoothScroll = Services.prefs.getBoolPref(data);
              break;
          }
        }
      });]]></field>

      <!-- replace the original method -->
      <method name="scrollByPixels">
        <parameter name="px"/>
        <parameter name="aSmoothScroll"/>
        <body><![CDATA[
          let newPx = (this._isScrolling || aSmoothScroll) ? px : this._distanceToRow(px);
          this.scrollPosition += newPx;
        ]]></body>
      </method>

      <method name="getOffsetAmountToScroll">
        <parameter name="element"/>
        <parameter name="amountToScroll"/>
        <body><![CDATA[
          var offset = 0, isScrollingLeft = amountToScroll > 0;
          if (amountToScroll != 0 && this.offsetAmountToScroll &&
              !TabmixTabbar.isMultiRow) {
            let tab;
            if (isScrollingLeft)
              tab = TMP_TabView.nextVisibleSibling(element);
            else
              tab = TMP_TabView.previousVisibleSibling(element);
            if (tab) {
              offset = Math.min(50, this.offsetRatio * tab.getBoundingClientRect().width);
              if (!isScrollingLeft)
                offset = Math.min(this.scrollPosition, offset);
            }
          }
          return isScrollingLeft ? offset : -offset;
        ]]></body>
      </method>

      <method name="_distanceToRow">
        <parameter name="amountToScroll"/>
        <body><![CDATA[
          if (!TabmixTabbar.isMultiRow)
            return amountToScroll;
          let rowHeight = this.singleRowHeight;
          let position = this.scrollPosition;
          return Math.round((amountToScroll + position) / rowHeight) * rowHeight - position;
        ]]></body>
      </method>

      <field name="_verticalAnimation">6</field>
      <field name="_smoothVerticalScroll">6</field>
      <field name="_singleRowHeight">null</field>

      <property name="singleRowHeight" readonly="true">
        <getter><![CDATA[
          if (this._singleRowHeight)
            return this._singleRowHeight;

          if (TabmixTabbar.visibleRows > 1) {
            this._singleRowHeight = TabmixTabbar.singleRowHeight;
            this._smoothVerticalScroll = Math.round(this._singleRowHeight / 4);
            return this._singleRowHeight;
          }

          // still in one row
          var tabs = document.getBindingParent(this);
          let height = tabs.selectedItem.boxObject.height;
          if (height)
            return height;

          // if selectedItem don't have height find other tab that does
          for (let i = 0; i < tabs.childNodes.length; i++) {
             let tab = tabs.childNodes[i];
             let height = tab.boxObject.height;
             if (height)
               return height;
          }

          return this._scrollbox.boxObject.height;
        ]]></getter>
      </property>

      <method name="isElementVisible">
        <parameter name="element"/>
        <body><![CDATA[
          if (!element || !element.parentNode || element.collapsed || element.hidden)
            return false;

          // pinned tabs are always visible
          if (element.pinned)
            return true;

          var [start, end] = this._startEndProps;
          if (this.orient != "vertical" && Tabmix.rtl)
            [end, start] = [start, end];
          var rect = this.scrollClientRect;
          var containerStart = rect[start];
          var containerEnd = rect[end];
          rect = element.getBoundingClientRect();
          var elementStart = rect[start];
          var elementEnd = rect[end];

          // we don't need the extra check with scrollContentRect
          // like in ensureElementIsVisible, the element will be invisible anyhow.
          if (elementStart < containerStart)
            return false;
          else if (containerEnd < elementEnd)
            return false;

          return true;
        ]]></body>
      </method>

      <method name="_enterVerticalMode">
        <parameter name="blockUnderflow"/>
        <body><![CDATA[
          // when widthFitTitle is false we enter vertical mode only after we are in overflow
          // if first or last tab is unvisible enter vertical mode
          // we can get here from new tabs, window resize tabs change width
          // so we call this function after 3 events TabOpen, overflow and scroll
          this.__needToSetVerticalOrient = false;
          if (this.orient == "vertical")
            return;

          var tabBar = document.getBindingParent(this);
          tabBar.adjustNewtabButtonvisibility();
          let tabs = this._getScrollableElements();
          let isFirstTabVisible = this.isElementVisible(tabs[0]);
          let isLastTabVisible = this.isElementVisible(tabs[tabs.length-1]);
          if (!isFirstTabVisible || !isLastTabVisible) {
            // show Newtabbutton for the first time
            // for the case last tab in row fill the all strip and the button
            // is on the next row
            tabBar.disAllowNewtabbutton = false;
            this.orient = "vertical";
            Tabmix.setItem(tabBar, "multibar", true);
            Tabmix.setItem("TabsToolbar", "multibar", true);
            if (tabBar.updateVerticalTabStrip() == null)
              TabmixTabbar._failedToEnterVerticalMode = true;
            if (blockUnderflow && this.orient == "vertical")
              this.blockUnderflow = true;
          }
        ]]></body>
      </method>

      <field name="firstVisibleRow">null</field>
      <method name="setFirstTabInRow">
        <parameter name="scroll"/>
        <body><![CDATA[
          let firstVisibleRow = Math.round(this.scrollPosition / this.singleRowHeight) + 1;
          if (scroll) {
            if (this.firstVisibleRow == firstVisibleRow)
              return;
          }
          else if (this.firstVisible.tab) {
            let rect = this.firstVisible.tab.getBoundingClientRect();
            if (this.firstVisible.x == rect.left && this.firstVisible.y == rect.top)
              return;
          }

          this.firstVisibleRow = firstVisibleRow;

          let tabBar = document.getBindingParent(this);
///XXX check if we can set the margin with animation when we scroll
          let end = Tabmix.ltr ? "right": "left";
          let containerEnd = this.scrollClientRect[end];
          let top = tabBar.topTabY;
          let tabs = this._getScrollableElements();
          let index, current = 0;
          for (let i = 0; i < tabs.length; i++) {
            let tab = tabs[i];
            if (tabBar.tabbrowser._removingTabs.indexOf(tab) != -1) {
              tab.removeAttribute("tabmix-firstTabInRow");
              continue;
            }
            let row = tabBar.getTabRowNumber(tab, top);
            if (row > current) {
              current = row;
              if (!tab.hasAttribute("tabmix-firstTabInRow"))
                tab.setAttribute("tabmix-firstTabInRow", true);
              else if (i > 0) {
                // remove the margin when the tab have place in the previous row
                let tabEnd = tabs[i-1].getBoundingClientRect()[end] + (Tabmix.ltr ? tab.getBoundingClientRect().width : 0);
                if (!Tabmix.compare(tabEnd, containerEnd, Tabmix.rtl)) {
                  tab.removeAttribute("tabmix-firstTabInRow");
                  continue;
                }
              }
              if (row == firstVisibleRow) {
                let rect = tab.getBoundingClientRect();
                this.firstVisible = {tab: tab, x: rect.left, y: rect.top};
                index = ++i;
                break;
              }
            }
            else if (tab.hasAttribute("tabmix-firstTabInRow"))
              tab.removeAttribute("tabmix-firstTabInRow");
          }
          for (let i = index; i < tabs.length; i++) {
            let tab = tabs[i];
            if (tab.hasAttribute("tabmix-firstTabInRow"))
              tab.removeAttribute("tabmix-firstTabInRow");
          }
        ]]></body>
      </method>

    </implementation>

    <handlers>
      <handler event="underflow" phase="capturing"><![CDATA[
        // filter underflow events which were dispatched on nested scrollboxes
        if (event.originalTarget != this._scrollbox)
          return;

        if (this.orient == "vertical") {
          // vertical scrollbox - Ignore horizontal events
          if (event.detail == 1 || this.blockUnderflow) {
            this.blockUnderflow = false;
            return;
          }
        }
        else {
          // horizontal scrollbox - Ignore vertical events
          if (event.detail == 0)
            return;
        }

        var tabs = document.getBindingParent(this);
        if (tabs.hasAttribute("multibar")) {
          //XXX don't do anything on Linux when hovering last tab and
          // we show close button on tab on hover
          if (!Tabmix.isPlatform("Linux") || TabmixTabbar.visibleRows == 1 ||
              (!tabs.visibleTabsLastChild.hasAttribute("showbutton") &&
               !tabs.visibleTabsLastChild.hasAttribute("showbutton_removed")))
            tabs.updateVerticalTabStrip();
        }
        else
          tabs.overflow = false;

        if (Tabmix.isVersion(50) && tabs._lastTabClosedByMouse)
          tabs._expandSpacerBy(this._scrollButtonDown.clientWidth);

        tabs.tabbrowser._removingTabs.forEach(tabs.tabbrowser.removeTab,
                                              tabs.tabbrowser);
        tabs._positionPinnedTabs();
      ]]></handler>

      <handler event="overflow"><![CDATA[
        // filter overflow events which were dispatched on nested scrollboxes
        if (event.originalTarget != this._scrollbox)
          return;

        var tabs = document.getBindingParent(this);
        if (this.orient == "vertical") {
          // vertical scrollbox - Ignore horizontal events
          if (event.detail == 1 || this.blockOverflow) {
            this.blockOverflow = false;
            return;
          }
        }
        else {
          // horizontal scrollbox - Ignore vertical events
          if (event.detail == 0)
            return;
          if (TabmixTabbar.isMultiRow && !this._enterVerticalModeTimeout) {
            this.__needToSetVerticalOrient = true;
            // when widthFitTitle is false we enter vertical mode only after we are in overflow
            // if first or last tab is unvisible enter vertical mode
            let self = this;
            this._enterVerticalModeTimeout = setTimeout(function() {
              self._enterVerticalModeTimeout = null;
              self._enterVerticalMode(true);
            }, 25);
            return;
          }
        }

        if (TabmixTabbar.isMultiRow) {
          //XXX don't do anything on Linux when hovering last tab and
          // we show close button on tab on hover
          if (!Tabmix.isPlatform("Linux") || TabmixTabbar.visibleRows == 1 ||
              !tabs.visibleTabsLastChild.hasAttribute("showbutton"))
            tabs.updateVerticalTabStrip();
        }
        else
          tabs.overflow = true;

        tabs._positionPinnedTabs();
      ]]></handler>

      <handler event="scroll"><![CDATA[
        if (this.__needToSetVerticalOrient)
          this._enterVerticalMode();

        let tabBar = document.getBindingParent(this);
        if (Tabmix.isVersion(50))
          tabBar._unlockTabSizing();

        if (TabmixTabbar.isMultiRow && tabBar.firstChild.pinned)
          this.setFirstTabInRow(true);
      ]]></handler>

    </handlers>
  </binding>

  <!-- for tabbar on the bottom of the screen -->
  <binding id="toolbar"
           extends="chrome://global/content/bindings/toolbar.xml#toolbar">
    <content>
        <xul:hbox flex="1"
                  xbl:inherits="orient,width"
                  anonid="toolbar-innerbox"
                  class="tabmixplus-toolbar-inner-box">
          <xbl:children/>
        </xul:hbox>
    </content>
    <implementation implements="nsIDOMEventListener">
      <constructor>
        <![CDATA[
          //XXX we don't check for aEvent.target != window to catch changs in browser-bottombox
          // try to improve it
          window.addEventListener("resize", this.tabmixHandleEvent, false);
        ]]>
      </constructor>

      <destructor>
        <![CDATA[
          window.removeEventListener("resize", this.tabmixHandleEvent, false);
        ]]>
      </destructor>

      <field name="tabmixToolbarInnerBox" readonly="true">
        document.getAnonymousElementByAttribute(this, 'anonid', 'toolbar-innerbox');
      </field>

      <method name="tabmixHandleEvent">
        <parameter name="aEvent"/>
        <body><![CDATA[
          switch (aEvent.type) {
            case "resize":
              gTMPprefObserver.updateTabbarBottomPosition(aEvent);
              break;
          }
        ]]></body>
      </method>

    </implementation>
  </binding>

</bindings>
