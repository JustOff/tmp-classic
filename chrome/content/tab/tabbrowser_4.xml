<?xml version="1.0"?>

<!DOCTYPE bindings [
<!ENTITY % identityDTD SYSTEM "chrome://tabmixplus/locale/pref-tabmix.dtd" >
%identityDTD;
<!ENTITY % globalDTD SYSTEM "chrome://global/locale/global.dtd">
%globalDTD;
<!ENTITY % tabBrowserDTD SYSTEM "chrome://browser/locale/tabbrowser.dtd" >
%tabBrowserDTD;
]>

<bindings id="tabmixbindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="tabbrowser-close-tab-button"
           extends="chrome://global/content/bindings/toolbarbutton.xml#toolbarbutton">
    <implementation>
      <constructor>
        <![CDATA[
          this.classList.add("toolbarbutton-1");
        ]]>
      </constructor>
    </implementation>
    <handlers>
      <handler event="click" button="1" action="TMP_ClosedTabs.undoCloseTab();"/>
    </handlers>
  </binding>

  <binding id="tabmix-tab-label">
    <content>
      <xul:label flex="1"
                 xbl:inherits="value=labelvalue,crop,accesskey,fadein,pinned,selected"
                 class="tab-text tab-label"
                 role="presentation"/>
    </content>
  </binding>

  <binding id="tabmix-tabbrowser-tab" display="xul:hbox"
            extends="chrome://tabmixplus/content/tab/tabbrowser_proxy.xml#tabmix-tabbrowser-tab-proxy">
    <content context="tabContextMenu" closetabtext="&closeTab.label;">
      <xul:hbox class="tab-image-left tab-startcap tab-left tab-left-border" xbl:inherits="selected,hover"/>
      <xul:hbox class="tab-drag-indicator-left"/>
      <xul:stack class="tab-stack" flex="1">
        <xul:hbox xbl:inherits="pinned,selected,titlechanged,fadein"
                  class="tab-background">
          <xul:hbox xbl:inherits="pinned,selected,titlechanged"
                    class="tab-background-start"/>
          <xul:hbox xbl:inherits="pinned,selected,titlechanged"
                    class="tab-background-middle"/>
          <xul:hbox xbl:inherits="pinned,selected,titlechanged"
                    class="tab-background-end"/>
        </xul:hbox>
        <xul:vbox class="tab-progress-container">
          <xul:progressmeter class="tab-progress" mode="normal"
                             xbl:inherits="value=tab-progress,fadein,pinned,selected"/>
        </xul:vbox>
        <xul:hbox xbl:inherits="pinned,selected,titlechanged"
                  class="tab-content" align="center">
            <xul:stack class="tab-icon" xbl:inherits="fadein,pinned,selected">
              <xul:image xbl:inherits="fadein,pinned,busy,progress,selected"
                         class="tab-throbber"
                         role="presentation"/>
              <xul:image xbl:inherits="src=image,fadein,pinned,selected"
                         class="tab-icon-image"
                         validate="never"
                         role="presentation"/>
              <xul:image class="tab-protect-icon" />
              <xul:image class="tab-lock-icon"/>
              <xul:image class="tab-reload-icon"/>
            </xul:stack>
          <xul:label flex="1"
                     anonid="tab-label" tabmix="true"
                     xbl:inherits="value=visibleLabel,labelvalue=label,crop,accesskey,fadein,pinned,selected"
                     class="tab-text tab-label"
                     role="presentation"/>
          <xul:toolbarbutton anonid="tmp-close-button"
                             xbl:inherits="fadein,pinned,selected"
                             class="tab-close-button close-icon"/>
        </xul:hbox>
      </xul:stack>
      <xul:hbox class="tab-drag-indicator-right"/>
      <xul:hbox class="tab-image-right tab-endcap tab-right tab-right-border" xbl:inherits="selected,hover"/>
    </content>

    <implementation>
    <constructor>
      <![CDATA[
        if ("tabmix_inited" in this)
          return;
        this.tabmix_inited = true;
      ]]>
    </constructor>
    <field name="mIsHover">
      false
    </field>
    <field name="mButtonId">
      0
    </field>
    <field name="mFocusId">
      0
    </field>
    <field name="mSelect">
      0
    </field>
    <field name="tabmix_mouseover">
      0
    </field>

    <property name="_isProtected" readonly="true">
      <getter><![CDATA[
        return this.hasAttribute("protected") || this.pinned ||
                  ("permaTabs" in window && this.hasAttribute("isPermaTab"));
      ]]></getter>
    </property>

    <property name="mouseHoverSelect" readonly="true">
      <getter><![CDATA[
        try {
          return Tabmix.prefs.getBoolPref("mouseOverSelect");
        }
        catch(e) {
          return false;
        }
      ]]></getter>
    </property>
    <property name="mouseDownSelect" readonly="true">
      <getter><![CDATA[
        try {
          return Tabmix.prefs.getBoolPref("selectTabOnMouseDown");
        }
        catch(e) {
          return false;
        }
      ]]></getter>
    </property>
    <property name="mouseHoverSelectDelay" readonly="true">
      <getter><![CDATA[
        try {
          return Tabmix.prefs.getIntPref("mouseOverSelectDelay");
        }
        catch(e) {
          return 250;
        }
      ]]></getter>
    </property>
    <property name="tabXDelay" readonly="true">
      <getter><![CDATA[
        try {
          return Tabmix.prefs.getIntPref("tabs.closeButtons.delay");
        }
        catch(e) {
        return 0;
        }
      ]]></getter>
    </property>

    <property name="baseY"
              readonly="true"
              onget="return this.boxObject.y+this.boxObject.height;"/>

    <method name="onMouseOver">
      <parameter name="aEvent"/>
      <body><![CDATA[
        var anonid = aEvent.originalTarget.getAttribute("anonid");
        if (anonid == "tmp-close-button")
          this.mOverCloseButton = true;
        this.mIsHover = true;
        this.mButtonId = window.setTimeout(this.setShowButton, this.tabXDelay, this);
        if (this.mouseHoverSelect)
          this.mFocusId = window.setTimeout(this.doMouseHoverSelect, this.mouseHoverSelectDelay, this);

        if (TabmixSvc.australis) {
          this.tabmix_mouseover = window.setTimeout(function(self) {
            clearTimeout(self.tabmix_mouseover);
            TabmixTabbar.updateBeforeAndAfter(true);
          }, 0, this);
        }
      ]]></body>
    </method>

    <method name="doMouseHoverSelect">
      <parameter name="aTab"/>
      <body><![CDATA[
        if (!aTab || !aTab.parentNode)
          return; // this tab already removed....

        var b = aTab.parentNode.tabbrowser;
        if (b.hasAttribute("preventMouseHoverSelect"))
            b.removeAttribute("preventMouseHoverSelect");
        else if (aTab.mIsHover)
           aTab.parentNode.selectedItem = aTab;
      ]]></body>
    </method>

    <method name="setShowButton">
      <parameter name="aTab"/>
      <body><![CDATA[
        if (!aTab || !aTab.parentNode)
          return; // this tab already removed....

        let pref = Tabmix.prefs.getIntPref("tabs.closeButtons");
        if (pref != 2 && pref != 4)
          return;

        if (aTab.mIsHover && aTab.getAttribute("showbutton") != "on" &&
            !aTab.hasAttribute("dragged")) {
          if (TabmixTabbar.widthFitTitle)
            aTab.style.setProperty("width", aTab.getBoundingClientRect().width + "px", "important");
          aTab.setAttribute("showbutton", "on");
          aTab.parentNode.__showbuttonTab = aTab;
        }
      ]]></body>
    </method>

    <method name="onMouseOut">
      <parameter name="aEvent"/>
      <body><![CDATA[
        var anonid = aEvent.originalTarget.getAttribute("anonid");
        if (anonid == "tmp-close-button")
          this.mOverCloseButton = false;
        this.mIsHover = false;
        clearTimeout(this.mButtonId);
        this.mButtonId = window.setTimeout(this.removeShowButton, this.tabXDelay, this);
        if (this.mouseHoverSelect && this.mFocusId)
          clearTimeout(this.mFocusId);

        if (TabmixSvc.australis) {
          clearTimeout(this.tabmix_mouseover);
          let positionalTabs = this.parentNode._tabmixPositionalTabs;
          if (positionalTabs.beforeHoveredTab) {
            positionalTabs.beforeHoveredTab.removeAttribute("tabmix-removed-beforehovered");
            positionalTabs.beforeHoveredTab = null;
          }
          if (positionalTabs.afterHoveredTab) {
            positionalTabs.afterHoveredTab.removeAttribute("tabmix-removed-afterhovered");
            positionalTabs.afterHoveredTab = null;
          }
        }
      ]]></body>
    </method>

    <method name="removeShowButton">
      <parameter name="aTab"/>
      <body><![CDATA[
        if (!aTab || !aTab.parentNode)
          return; // this tab already removed....

        if (!aTab.mIsHover && aTab.hasAttribute("showbutton")) {
          aTab.removeAttribute("showbutton");
          aTab.style.removeProperty("width");
          // we use this in Linux to prevent underflow
          // that trigger by hidding the close button
          aTab.setAttribute("showbutton_removed", true);
          setTimeout(function(tab) {tab.removeAttribute("showbutton_removed");}, 50, aTab);
          if (aTab == aTab.parentNode.__showbuttonTab)
            delete aTab.parentNode.__showbuttonTab;
        }
      ]]></body>
    </method>

    <method name="onMouseCommand">
      <parameter name="aEvent"/>
      <body><![CDATA[
        let isSelected = this == this.parentNode.selectedItem;
        Tabmix.setItem(this, "clickOnCurrent",
                       isSelected && aEvent.detail == 1 || null);
        if (isSelected)
          return;

        // don't allow mouse click/down with modifiers to select tab
        if (aEvent.shiftKey || aEvent.ctrlKey || aEvent.altKey || aEvent.metaKey)
          aEvent.stopPropagation();
        else {
          this.parentNode._selectNewTab(this);
          let isTabFocused = false;
          try {
            isTabFocused = (document.commandDispatcher.focusedElement == this);
          } catch (e) {}
          if (!isTabFocused) {
            this.setAttribute("ignorefocus", "true");
            this.mSelect = setTimeout(function (tab) tab.removeAttribute("ignorefocus"), 0, this);
          }
        }
      ]]></body>
    </method>

    <method name="clearTimeouts">
      <body><![CDATA[
        let timeouts = ["mSelect", "mFocusId", "mButtonId", "autoReloadTimerID", "tabmix_mouseover"];
        timeouts.forEach(function(aTimeout) {
          if (aTimeout in this && this[aTimeout]) {
            clearTimeout(this[aTimeout]);
            this[aTimeout] = null;
          }
        }, this);
      ]]></body>
    </method>

    <destructor>
      <![CDATA[
          this.clearTimeouts();
      ]]>
    </destructor>

    </implementation>

    <handlers>
      <handler event="mouseover">
      <![CDATA[
        this.onMouseOver(event);
      ]]>
      </handler>

      <handler event="mouseout">
      <![CDATA[
        this.onMouseOut(event);
      ]]>
      </handler>

      <handler event="mousedown" button="0" phase="capturing">
      <![CDATA[
        if (this.selected) {
          this.style.MozUserFocus = 'ignore';
          this.clientTop; // just using this to flush style updates
        }
        // prevent chrome://global/content/bindings/tabbox.xml#tab mousedown handler
        if (this.mOverCloseButton)
          event.stopPropagation();
        else {
          if (this.mouseDownSelect)
            this.onMouseCommand(event);
          else
            event.stopPropagation();
        }
      ]]>
      </handler>
    </handlers>
  </binding>

  <!-- tabbrowser-tabs bindings for Firefox 4.0+ -->
  <binding id="tabmix-tabbrowser-tabs"
           extends="chrome://tabmixplus/content/tab/tabbrowser_proxy.xml#tabmix-tabbrowser-tabs-proxy">
    <implementation implements="nsIDOMEventListener">

      <field name="tabstripInnerbox" readonly="true">
        document.getAnonymousElementByAttribute(this.mTabstrip._scrollbox, "class", "box-inherit scrollbox-innerbox");
      </field>

      <constructor>
        <![CDATA[
          Tabmix.initialization.run("init", this);
        ]]>
      </constructor>

      <method name="updateVerticalTabStrip">
        <parameter name="aReset"/>
        <body><![CDATA[
          if (Tabmix.extensions.verticalTabBar || gInPrintPreviewMode || FullScreen._isChromeCollapsed ||
              !this.visible && TabmixTabbar.visibleRows == 1)
            return null;
          if (this._inUpdateVerticalTabStrip)
            return this.getAttribute("multibar");
          this._inUpdateVerticalTabStrip = true;

          // we must adjustNewtabButtonvisibility before get lastTabRowNumber
          this.adjustNewtabButtonvisibility();
          let visibleRows = TabmixTabbar.visibleRows;
          // this.lastTabRowNumber is null when we hide the tabbar
          let rows = aReset || this.childNodes.length == 1 ? 1 : (this.lastTabRowNumber || 1);

          let currentMultibar = this.getAttribute("multibar") || null;
          let maxRow = Tabmix.prefs.getIntPref("tabBarMaxRow");
          // we need to check for the case that last row of tabs is empty and we still have hidden row on top
          // this can occur when we close last tab in the last row or when some tab changed width
          if (rows > 1 && rows - maxRow < 0 && this.overflow && this.canScrollTabsLeft) {
            // try to scroll all the way up
            this.mTabstrip.scrollByPixels((rows - maxRow) * this.mTabstrip.singleRowHeight);
            // get lastTabRowNumber after the scroll
            rows = this.lastTabRowNumber;
          }

          let multibar;
          if (rows == 1)
            multibar = null; // removeAttribute "multibar"
          else if (rows > maxRow)
            [multibar, rows] = ["scrollbar", maxRow];
          else
            multibar = "true"

          if (currentMultibar != multibar) {
            Tabmix.setItem(this, "multibar", multibar);
            Tabmix.setItem("TabsToolbar", "multibar", multibar);
          }

          Tabmix.tabsUtils.setTabStripOrient();
          TabmixTabbar.setHeight(rows, aReset);

          if (this.mTabstrip.orient == "vertical")
            this.overflow = multibar == "scrollbar";

          if (!this.overflow) {
            // prevent new-tab-button on the right from flickering when new tabs animate is on.
            if (this.disAllowNewtabbutton && Services.prefs.getBoolPref("browser.tabs.animate")) {
              // after 250ms new tab is fully opened
              if (!this.adjustNewtabButtonTimeout) {
                let timeout = 250, callerName = Tabmix.callerName();
                if (callerName == "onxbloverflow") {
                  let timeFromLastTabOpenedTime = Date.now() - Tabmix._lastTabOpenedTime;
                  if (timeFromLastTabOpenedTime < 250)
                    timeout = 0;
                }
              /**
                no need to change newTabButton visibility in order to calculate
                its position
                // Don't reset adjustNewtabButtonvisibility if multibar or rows
                // didn't changed or when we get here from _enterVerticalMode
                if (callerName != "_enterVerticalMode" &&
                     (multibar != currentMultibar || rows != visibleRows))
                  this.disAllowNewtabbutton = false;
               */
                let self = this;
                this.adjustNewtabButtonTimeout = setTimeout(function() {
                  self.adjustNewtabButtonvisibility();
                  self.adjustNewtabButtonTimeout = null;
                }, timeout);
              }
            }
            else
              this.adjustNewtabButtonvisibility();
          }

          this._inUpdateVerticalTabStrip = false;
          return multibar;
        ]]></body>
      </method>

      <property name="overflow">
        <getter><![CDATA[
          return this.hasAttribute("overflow");
        ]]></getter>
        <setter><![CDATA[
          // don't do anything if other extensions set orient to vertical
          // when we arn't use it.
          if (!TabmixTabbar.isMultiRow && this.mTabstrip.orient == "vertical")
            return val;

          if (val != this.overflow) {
            if (val)
              this.setAttribute("overflow", "true");
            else
              this.removeAttribute("overflow");
            TabmixTabbar.showNewTabButtonOnSide(val, "right-side");
            this.mTabstrip.updateOverflow(val);
          }
          return val;
        ]]></setter>
      </property>

      <property name="canScrollTabsLeft" readonly="true"
                onget="return !this.mTabstrip._scrollButtonUp.disabled;"/>

      <property name="canScrollTabsRight" readonly="true"
                onget="return !this.mTabstrip._scrollButtonDown.disabled;"/>

      <!--
        check that we have enough room to show new tab button after the last tab in the current row
        we don't want the button to be on the next row when the tab is on the current row
      -->
      <method name="adjustNewtabButtonvisibility">
        <body><![CDATA[
          if (!TabmixTabbar.isMultiRow && this.mTabstrip.orient == "vertical")
            return;

          if (!this._checkNewtabButtonVisibility) {
            TabmixTabbar.showNewTabButtonOnSide(this.overflow, "right-side");
            return;
          }

          // when Private-tab enabled/disabled we need to reset
          // tabsNewtabButton and afterTabsButtonsWidth
          if (!Tabmix.tabsNewtabButton)
            Tabmix.getAfterTabsButtonsWidth();

         var lastTab = Tabmix.visibleTabs.last;
         // button is visible
         //         A: last tab and the button are in the same row - check if we have room for the button in this row
         //         B: last tab and the button are NOT in the same row  - NG - hide the button
         if (!this.disAllowNewtabbutton) {
           let sameRow = TabmixTabbar.inSameRow(lastTab, Tabmix.tabsNewtabButton);
           if (sameRow) {
             let tabstripEnd = this.mTabstrip.scrollBoxObject.screenX + this.mTabstrip.scrollBoxObject.width;
             let buttonEnd = Tabmix.tabsNewtabButton.boxObject.screenX + Tabmix.tabsNewtabButton.boxObject.width
             this.disAllowNewtabbutton = buttonEnd > tabstripEnd;
           }
           else
             this.disAllowNewtabbutton = true;
           return;
         }
         // button is NOT visible
         //         A: 2 last tabs are in the same row - check if we have room for the button in this row
         //         B: 2 last tabs are NOT in the same row - check if we have room for the last tab + button
         //              after previous to last tab.
         else {
           // ignor the case that this tab width is larger then the tabbar
           let previousTab = Tabmix.visibleTabs.previous(lastTab);
           if (!previousTab) {
             this.disAllowNewtabbutton = false;
             return;
           }

           // buttons that are not on TabsToolbar or not visible are null
           let newTabButtonWidth = function(aOnSide) {
             let width = 0, privatTabButton = TabmixTabbar.newPrivateTabButton();
             if (privatTabButton)
               width += aOnSide ? privatTabButton.boxObject.width : Tabmix.afterTabsButtonsWidth[1];
             if (Tabmix.sideNewTabButton)
               width += aOnSide ? Tabmix.sideNewTabButton.boxObject.width : Tabmix.afterTabsButtonsWidth[0];
             return width;
           }
           let tsbo = this.mTabstrip.scrollBoxObject;
           let tsboEnd = tsbo.screenX + tsbo.width + newTabButtonWidth(true);
           if (TabmixTabbar.inSameRow(lastTab, previousTab)) {
             let buttonEnd = lastTab.boxObject.screenX + lastTab.boxObject.width + newTabButtonWidth();
             this.disAllowNewtabbutton = buttonEnd > tsboEnd;
             return;
           }
           else {
             let lastTabEnd = previousTab.boxObject.screenX + previousTab.boxObject.width
                                         + lastTab.boxObject.width;
             // both last tab and new tab button are in the next row
             if (lastTabEnd > tsboEnd)
               this.disAllowNewtabbutton = false;
             else
               this.disAllowNewtabbutton = lastTabEnd + newTabButtonWidth() > tsboEnd;
             return;
           }
         }
        ]]></body>
      </method>

      <property name="disAllowNewtabbutton">
        <getter><![CDATA[
          return document.getElementById("TabsToolbar").getAttribute("tabmix-show-newtabbutton") == "temporary-right-side";
        ]]></getter>
        <setter><![CDATA[
          let newVal = this.overflow || val;
          TabmixTabbar.showNewTabButtonOnSide(this.overflow || val, "temporary-right-side");
          return newVal;
        ]]></setter>
      </property>

      <property name="topTabY" readonly="true">
        <getter><![CDATA[
          return this.tabstripInnerbox.boxObject.y + Tabmix.getStyle(this.tabstripInnerbox, "paddingTop");
        ]]></getter>
      </property>

      <property name="lastTabRowNumber" readonly="true">
        <getter><![CDATA[
          return this.getTabRowNumber(Tabmix.visibleTabs.last, this.topTabY);
        ]]></getter>
      </property>

      <method name="getTabRowNumber">
        <parameter name="aTab"/>
        <parameter name="aTop"/>
        <body><![CDATA[
/*XXX we can use aTab.getBoundingClientRect().top if we do the same in topTabY */
          var height = aTab ? aTab.boxObject.height : 0;
          if (height == 0) // don't panic
            return 1;
          // some theme add marginTop/marginBottom to tabs
          var cStyle = window.getComputedStyle(aTab, null);
          var marginTop = parseInt(cStyle["marginTop"]) || 0;
          var marginBottom = parseInt(cStyle["marginBottom"]) || 0;
          height += marginTop + marginBottom;

          var tabBottom = aTab.boxObject.y - marginTop + height;
          return Math.round((tabBottom - aTop)/height);
        ]]></body>
      </method>

      <method name="_notifyBackgroundTab">
        <parameter name="aTab"/>
        <body><![CDATA[
          if (aTab.pinned)
            return;
          // Is the new tab already completely visible?
          if (this.mTabstrip.isElementVisible(aTab))
            return;

          var scrollRect = this.mTabstrip.scrollClientRect;
          var tab = aTab.getBoundingClientRect();
          this.mTabstrip._calcTabMargins(aTab);

          // DOMRect left/right properties are immutable.
          tab = {left: tab.left, right: tab.right, top: tab.top, bottom: tab.bottom};

          if (this.mTabstrip.smoothScroll) {
            let selected = !this.selectedItem.pinned &&
                           this.selectedItem.getBoundingClientRect();

            if (Tabmix.isVersion(310) && !TabmixTabbar.isMultiRow) {
              if (selected) {
                selected = {left: selected.left, right: selected.right};
                // Need to take in to account the width of the left/right margins on tabs.
                selected.left = selected.left + this.mTabstrip._tabMarginLeft;
                selected.right = selected.right - this.mTabstrip._tabMarginRight;
              }

              tab.left += this.mTabstrip._tabMarginLeft;
              tab.right -= this.mTabstrip._tabMarginRight;
            }

            // Can we make both the new tab and the selected tab completely visible?
            if (!selected ||
                !TabmixTabbar.isMultiRow && Math.max(tab.right - selected.left, selected.right - tab.left) <= scrollRect.width ||
                 TabmixTabbar.isMultiRow && Math.max(tab.bottom - selected.top, selected.bottom - tab.top) <= scrollRect.height) {
              if (this.overflow)
                this.mTabstrip.ensureElementIsVisible(aTab);
              return;
            }

            if (TabmixTabbar.isMultiRow)
              this.mTabstrip._smoothScrollByPixels(selected.top - scrollRect.top);
            else
              this.mTabstrip._smoothScrollByPixels(this.mTabstrip._isRTLScrollbox ?
                                                 selected.right - scrollRect.right :
                                                 selected.left - scrollRect.left);
          }

          if (!this._animateElement.hasAttribute("notifybgtab")) {
            this._animateElement.setAttribute("notifybgtab", "true");
            setTimeout(function (ele) {
              ele.removeAttribute("notifybgtab");
            }, 150, this._animateElement);
          }
        ]]></body>
      </method>

      <!-- Deprecated stuff, implemented for backwards compatibility. -->
      <method name="isTabVisible">
        <parameter name="aIndex"/>
        <body><![CDATA[
          return this.mTabstrip.isElementVisible(this.childNodes.item(aIndex));
        ]]></body>
      </method>
      <method name="ensureTabIsVisible">
        <parameter name="aIndex"/>
        <parameter name="aSmoothScroll"/>
        <body><![CDATA[
          if (!this.isTabVisible(aIndex))
            this.mTabstrip.ensureElementIsVisible(this.childNodes.item(aIndex), aSmoothScroll);
        ]]></body>
      </method>
      <property name="lastTabVisible" readonly="true">
        <getter><![CDATA[
          return this.mTabstrip.isElementVisible(Tabmix.visibleTabs.last);
        ]]></getter>
      </property>

      <property name="collapsedTabs" onget="return 0;" onset="return 0;"/>
      <property name="realCollapsedTabs" readonly="true" onget="return 0;"/>

    </implementation>

    <handlers>
      <handler event="MozMouseHittest" button="0"  phase="capturing"><![CDATA[
        if (Tabmix.keyModifierDown || event.detail > 0)
          event.stopPropagation();
      ]]></handler>

      <handler event="dblclick" phase="capturing"><![CDATA[
        if (Tabmix.prefs.getBoolPref("tabbar.click_dragwindow") &&
            Tabmix.prefs.getBoolPref("tabbar.dblclick_changesize") &&
            !TabmixSvc.isMac && event.target.localName == "tabs") {
          let displayAppButton = !(document.getElementById("titlebar") || document.getElementById("appmenu-toolbar-button")).hidden;
          let tabsOnTop = !window.TabsOnTop || TabsOnTop.enabled;
          if (TabsInTitlebar.enabled ||
              (displayAppButton && tabsOnTop && this.parentNode._dragBindingAlive))
            return;
        }
        TabmixTabClickOptions.onTabBarDblClick(event);
      ]]></handler>

      <handler event="click" phase="capturing"><![CDATA[
        TabmixTabClickOptions.onTabClick(event);
      ]]></handler>

      <handler event="dragstart" phase="capturing"><![CDATA[
        if (this.useTabmixDragstart(event))
          TMP_tabDNDObserver.onDragStart(event);
      ]]></handler>

      <handler event="drop" phase="capturing"><![CDATA[
        if (this.useTabmixDnD(event))
          TMP_tabDNDObserver.onDrop(event);
      ]]></handler>

      <handler event="dragend" phase="capturing"><![CDATA[
        if (this.orient == "horizontal")
          TMP_tabDNDObserver.onDragEnd(event);
      ]]></handler>

      <handler event="dragexit" phase="capturing"><![CDATA[
        if (this.useTabmixDnD(event))
          TMP_tabDNDObserver.onDragExit(event);
      ]]></handler>
    </handlers>

  </binding>

</bindings>
