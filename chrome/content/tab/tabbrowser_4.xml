<?xml version="1.0"?>

<!DOCTYPE bindings [
<!ENTITY % identityDTD SYSTEM "chrome://tabmixplus/locale/pref-tabmix.dtd" >
%identityDTD;
<!ENTITY % globalDTD SYSTEM "chrome://global/locale/global.dtd">
%globalDTD;
<!ENTITY % tabBrowserDTD SYSTEM "chrome://browser/locale/tabbrowser.dtd" >
%tabBrowserDTD;
]>

<bindings id="tabmixbindings_40"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="tabmix-tabbrowser-tab" display="xul:hbox"
        extends="chrome://tabmixplus/content/tab/tabmix_3.xml#browser-tab">
    <content context="tabContextMenu" closetabtext="&closeTab.label;">
      <xul:hbox class="tab-image-left tab-startcap tab-left tab-left-border" xbl:inherits="selected,hover"/>
      <xul:hbox class="tab-drag-indicator-left"/>
      <xul:stack class="tab-stack" flex="1">
        <xul:vbox class="tab-progress-container">
          <xul:progressmeter class="tab-progress" mode="normal"
                             xbl:inherits="value=tab-progress,fadein,pinned,selected"/>
        </xul:vbox>
        <xul:hbox xbl:inherits="pinned,selected,titlechanged,visited"
                  class="tab-background">
          <xul:hbox xbl:inherits="pinned,selected,titlechanged,visited"
                    class="tab-background-start"/>
          <xul:hbox xbl:inherits="pinned,selected,titlechanged,visited"
                    class="tab-background-middle"/>
          <xul:hbox xbl:inherits="pinned,selected,titlechanged,visited"
                    class="tab-background-end"/>
        </xul:hbox>
        <xul:hbox xbl:inherits="pinned,selected,titlechanged"
                  class="tab-content" align="center">
          <xul:toolbarbutton anonid="tmp-close-button"
                         xbl:inherits="fadein,pinned,selected"
                         tabindex="-1" button_side="left"
                         clickthrough="never"
                         class="tab-close-button always-left"/>
            <xul:stack class="tab-icon" xbl:inherits="fadein,pinned,selected">
              <xul:image xbl:inherits="fadein,pinned,busy,progress,selected"
                         class="tab-throbber"
                         role="presentation"/>
              <xul:image xbl:inherits="validate,src=image,fadein,pinned,selected"
                         class="tab-icon-image"
                         role="presentation"/>
              <xul:image class="tab-protect-icon" />
              <xul:image class="tab-lock-icon"/>
              <xul:image class="tab-reload-icon"/>
            </xul:stack>
            <xul:stack class="tab-text-stack" flex="1" xbl:inherits="fadein,pinned,selected">
              <xul:label flex="1"
                         xbl:inherits="value=label,crop,accesskey,fadein,pinned,selected"
                         class="tab-text tab-label"
                         role="presentation"/>
              <xul:hbox class="showhover-box">
                <xul:toolbarbutton anonid="tmp-close-button"
                                   tabindex="-1" clickthrough="never" class="showhover tabs-closebutton"/>
              </xul:hbox>
            </xul:stack>
          <xul:toolbarbutton anonid="tmp-close-button"
                           xbl:inherits="fadein,pinned,selected"
                           tabindex="-1" button_side="right"
                           clickthrough="never"
                           class="tab-close-button always-right"/>
        </xul:hbox>
      </xul:stack>
      <xul:hbox class="tab-drag-indicator-right"/>
      <xul:hbox class="tab-image-right tab-endcap tab-right tab-right-border" xbl:inherits="selected,hover"/>
    </content>
  </binding>

  <!-- tabbrowser-tabs bindings for Firefox 4.0+ -->
  <binding id="tabmix-tabbrowser-tabs"
            extends="chrome://tabmixplus/content/tab/tabmix_3.xml#tabmix-base-tabbrowser-tabs">
    <implementation>
      <field name="tabstripInnerbox" readonly="true">
        document.getAnonymousElementByAttribute(this.mTabstrip._scrollbox, "class", "box-inherit scrollbox-innerbox");
      </field>

      <field name="mTabsNewtabButton">
        document.getAnonymousElementByAttribute(this, "class", "tabs-newtab-button");
      </field>

      <constructor>
        <![CDATA[
          Tabmix.newDargnDrop = Tabmix.isVersion(80) && ("_handleTabDrag" in this) && true;

          if (!Tabmix.newDargnDrop)
            this.parentNode.addEventListener("dragover", TMP_tabDNDObserver._handleDragover, true);

          if (this.tabmix_inited_40) {
            this.tabmixTabbarPositionChanged();
            return;
          }
          Services.obs.addObserver(TMP_eventListener.observe, "browser-delayed-startup-finished", false);
          this.tabmix_inited_40 = true;
        ]]>
      </constructor>

      <destructor>
        <![CDATA[
          if (!Tabmix.newDargnDrop && this.parentNode)
            this.parentNode.removeEventListener("dragover", TMP_tabDNDObserver._handleDragover, true);
          this.tabbrowser.mTabDropIndicatorBar = null;
        ]]>
      </destructor>

      <method name="updateVerticalTabStrip">
        <parameter name="aReset"/>
        <body><![CDATA[
          if (Tabmix.extensions.treeStyleTab || !this.visible && TabmixTabbar.visibleRows == 1)
            return null;
          // we must adjustNewtabButtonvisibility before get lastTabRowNumber
          this.adjustNewtabButtonvisibility();
          // this.lastTabRowNumber is null when we hide the tabbar
          let rows = aReset ? 1 : (this.lastTabRowNumber || 1);
          let currentRows = TabmixTabbar.visibleRows;

          let currentMultibar = this.getAttribute("multibar") || null;
          let maxRow = this.maxRow;
          // we need to check for the case that last row of tabs is empty and we still have hidden row on top
          // this can occur when we close last tab in the last row or when some tab changed width
          if (rows > 1 && rows - maxRow < 0 && this.overflow && this.canScrollTabsLeft) {
            // try to scroll all the way up
            this.mTabstrip.scrollByPixels((rows - maxRow) * this.mTabstrip.singleRowHeight);
            // get lastTabRowNumber after the scroll
            rows = this.lastTabRowNumber;
          }
          let multibar;
          if (rows == 1)
            multibar = null; // removeAttribute "multibar"
          else if (rows > maxRow)
            [multibar, rows] = ["scrollbar", maxRow];
          else
            multibar = "true"

          if (rows > 1 && currentMultibar != multibar) {
            Tabmix.setItem(this, "multibar", multibar);
            Tabmix.setItem("TabsToolbar", "multibar", multibar);
          }

          this.setTabStripOrient();
          TabmixTabbar.setHeight(rows, aReset);

          // prevent new-tab-button on the right from flickering when new tabs animate is on.
          if (this.disAllowNewtabbutton && TabmixSvc.prefs.getBoolPref("browser.tabs.animate")) {
            this.disAllowNewtabbutton = false;
            let self = this;
            // after 300ms new tab is fully opened
            setTimeout(function() {self.adjustNewtabButtonvisibility();}, 300);
          }
          else
            this.adjustNewtabButtonvisibility();

          if (this.mTabstrip.orient == "vertical")
            this.overflow = multibar == "scrollbar";
          // if we are going to have scrool button on the left with multi-row
          // update _positionPinnedTabs also when show/hide the buttons
          if (currentMultibar != multibar || currentRows != rows)
            this._positionPinnedTabs();

          return multibar;
        ]]></body>
      </method>

      <method name="setTabStripOrient">
        <body><![CDATA[
          // we can't set dispaly:block and orient=vertical when widthFitTitle is false
          // and we are in one row.
          let vertical = TabmixTabbar.isMultiRow && 
              (TabmixTabbar.widthFitTitle || this.hasAttribute("multibar"));
          Tabmix.setItem(this.mTabstrip, "orient", vertical ? "vertical" : "horizontal");
          this.mTabstrip._isRTLScrollbox = !vertical && Tabmix.rtl;          
        ]]></body>
      </method>

      <field name="_previousNumPinned">1</field>
      <field name="_previousMaxPinnedTabsInRow">0</field>
      <field name="__startOffset">0</field>
      <field name="__extraStartMargin">10</field>

      <method name="_positionPinnedOnMultiRow">
        <parameter name="numPinned"/>
        <body><![CDATA[
          if (Tabmix.extensions.treeStyleTab)
            return;
          // we have to make sure that rearranging pinned tabs in rows don't change
          // overflow status.
          // when we increase maxPinnedTabsInRow we can change state from underflow to overflow.
          // when we decrease maxPinnedTabsInRow we can change state from overflow to underflow.
          if (!numPinned) {
            numPinned = this.tabbrowser._numPinnedTabs;
            if (numPinned == 0)
              return;
          }

          if (this.__startOffset == 0) {
            this._previousNumPinned = numPinned;
            this._previousMaxPinnedTabsInRow = numPinned;
            this._setPinnedTabsMargin(numPinned, 1, numPinned);
          }

          this.setAttribute("positionpinnedtabs", "true");
          let rows = TabmixTabbar.visibleRows, maxPinnedTabsInRow;
          let decrease = this._lastTabRowNumber < rows;
          // when we decrease rows, try to fit all pinned tab in equal number
          // of rows as normal tabs without changing the amount of normal tabs rows.
          if (numPinned > 1 && this._previousNumPinned == numPinned && decrease)
            maxPinnedTabsInRow = this._setTabContainerMargin(numPinned);
          else {
            maxPinnedTabsInRow = Math.floor(numPinned / rows);
            if (numPinned - maxPinnedTabsInRow * rows > 0)
              maxPinnedTabsInRow++;
          }
          if (maxPinnedTabsInRow < numPinned)
            this._setPinnedTabsMargin(numPinned, rows, maxPinnedTabsInRow);

          // we trigger underflow - prevet undefflow handler call this method again
          if (!decrease && this._lastTabRowNumber < rows)
            this.mTabstrip.blockUnderflow = true;

          this._previousNumPinned = numPinned;
          this._previousMaxPinnedTabsInRow = maxPinnedTabsInRow;
        ]]></body>
      </method>

      <method name="_setTabContainerMargin">
        <parameter name="numPinned"/>
        <body><![CDATA[
          // when we decrease rows, try to fit all pinned tab in equal number
          // of rows as normal tabs without changing the amount of normal tabs rows.
          let courrent = this._previousMaxPinnedTabsInRow;
          let width = this.__startOffset / courrent;
          let rows = Math.min(TabmixTabbar.visibleRows, this._lastTabRowNumber);
          let maxTabsInRow = Math.floor(numPinned / rows);
          if (numPinned - maxTabsInRow * rows > 0)
            maxTabsInRow++;
          if (maxTabsInRow != courrent) {
            let diff = maxTabsInRow < courrent ? -1 : 1;
            if (diff < 0)
              this.mTabstrip.blockUnderflow = true;
            else
              this.mTabstrip.blockOverflow = true;
            let extra = this.mTabstrip.scrollboxPaddingStart;
            if (rows > 1)
              extra += this.__extraStartMargin;
            this.style.MozMarginStart = maxTabsInRow * width + extra + "px";
            if (this._lastTabRowNumber != rows) {
              let extra = this.mTabstrip.scrollboxPaddingStart + this.__extraStartMargin;
              this.style.MozMarginStart = courrent * width + extra + "px";
              return courrent;
            }
            // reset multi-row, we have place for all tabs in one row.
            if (rows == 1) {
              this.updateVerticalTabStrip(true);
              this.__startOffset = 0;
            }
            if (diff < 0)
              this.mTabstrip.blockUnderflow = false;
            else
              this.mTabstrip.blockOverflow = false;
          }
          return maxTabsInRow;
        ]]></body>
      </method>

      <method name="_setPinnedTabsMargin">
        <parameter name="numPinned"/>
        <parameter name="aRows"/>
        <parameter name="maxTabsInRow"/>
        <body><![CDATA[
          let height = TabmixTabbar.singleRowHeight;
          let paddingStart = this.mTabstrip.scrollboxPaddingStart;
          let offset = 0, count = 0, extra = this.__extraStartMargin ;
          //XXX we assume that all pinned tabs have the same width
          let pinnedTabWidth = this.childNodes[0].scrollWidth;
          for (let row = 0; row < aRows, count < numPinned; row++) {
            let thisRowCount = count + maxTabsInRow > numPinned ? numPinned - count : maxTabsInRow;
            let width = (maxTabsInRow - thisRowCount) * pinnedTabWidth;
            for (let i = count + thisRowCount - 1; i >= count; i--) {
              let tab = this.childNodes[i];
              width += tab.scrollWidth;
              tab.style.MozMarginStart = - (width + paddingStart + extra) + "px";
              tab.style.marginTop = (height * row) + "px";
              tab.__row = row + 1;
            }
            count += thisRowCount;
            offset = Math.max(offset, width);
          }
          this.__startOffset = offset;
          this.style.MozMarginStart = offset + paddingStart + extra + "px";
        ]]></body>
      </method>

      <!--
      canScrollTabsLeft and canScrollTabsRight are in tabbrowser.xml for Firefox 3.5-3.6
      and in tabbrowser_4.xml for Firefox 4.0+.
      We drop the use of disableScrollTabsLeft and disableScrollTabsRight from Firefox 4.0+.
      -->
      <property name="canScrollTabsLeft" readonly="true"
                onget="return !this.mTabstrip._scrollButtonUp.disabled;"/>

      <property name="canScrollTabsRight" readonly="true"
                onget="return !this.mTabstrip._scrollButtonDown.disabled;"/>

      <property name="visibleTabsFirstChild" readonly="true">
        <getter><![CDATA[
          var tabs = this.childNodes;
          for (let i = 0; i < tabs.length; i++){
            let tab = tabs[i];
            if (!tab.hidden && this.tabbrowser._removingTabs.indexOf(tab) == -1)
              return tab;
          }
          return this.mCurrentTab;
        ]]></getter>
      </property>

      <property name="visibleTabsLastChild" readonly="true">
        <getter><![CDATA[
          // we only need the last visible tab,
          // find it directly instead of using this.visibleTabs
          var tabs = this.childNodes;
          for (let i = tabs.length - 1; i >= 0; i--){
            let tab = tabs[i];
            if (!tab.hidden && this.tabbrowser._removingTabs.indexOf(tab) == -1)
              return tab;
          }
          return this.mCurrentTab;
        ]]></getter>
      </property>

      <property name="lastTabVisible" readonly="true">
        <getter><![CDATA[
          if (this._isRTLScrollbox && !this.hasAttribute("multibar"))
            return this.mTabstrip.isElementVisible(this.visibleTabsFirstChild._tPos);

          return this.mTabstrip.isElementVisible(this.visibleTabsLastChild);
        ]]></getter>
      </property>

      <property name="disAllowNewtabbutton">
        <getter><![CDATA[
          return document.getElementById("TabsToolbar").hasAttribute("disAllowNewtabbutton");
        ]]></getter>
        <setter><![CDATA[
          if (val != this.disAllowNewtabbutton)
            Tabmix.setItem("TabsToolbar", "disAllowNewtabbutton", val || null);
          return val;
        ]]></setter>
      </property>

      <property name="collapsedTabs"
                onget="return 0;"
                onset="return 0;"/>

     <property name="_real_numPinnedTabs" readonly="true">
       <getter><![CDATA[
          var count = 0;
          for (let i = 0; i < this.childNodes.length; i++) {
            let tab = this.childNodes[i];
            if (!tab.pinned)
              break;

            if (this.tabbrowser._removingTabs.indexOf(tab) == -1)
               count++;
          }
          return count;
       ]]></getter>
     </property>

      <!-- collapsedTabs without pinned tabs -->
      <property name="realCollapsedTabs" readonly="true"
                onget="return 0;"/>

      <method name="isTabVisible">
        <parameter name="aIndex"/>
        <body><![CDATA[
          return this.mTabstrip.isElementVisible(this.childNodes.item(aIndex));
        ]]></body>
      </method>

      <method name="ensureTabIsVisible">
        <parameter name="aIndex"/>
        <parameter name="aSmoothScroll"/>
        <body><![CDATA[
          if (!this.isTabVisible(aIndex))
            this.mTabstrip.ensureElementIsVisible(this.childNodes.item(aIndex), aSmoothScroll);
        ]]></body>
      </method>

      <method name="rowScroll">
        <parameter name="factor"/>
        <body>
        <![CDATA[
        ]]>
        </body>
      </method>

      <property name="_lastTabRowNumber" readonly="true">
        <getter><![CDATA[
          return this.getTabRowNumber(this.visibleTabsLastChild, this.topTabY);
        ]]></getter>
      </property>

      <property name="lastTabRowNumber" readonly="true">
        <getter><![CDATA[
          let rows = this.getTabRowNumber(this.visibleTabsLastChild, this.topTabY);

          let numPinned = this.tabbrowser._numPinnedTabs;
          if (numPinned) {
            let lastPinnedTabRow = this.childNodes[numPinned - 1].__row || 1;
            rows = Math.max(lastPinnedTabRow, rows);
          }

          return rows;
        ]]></getter>
      </property>

      <method name="tabmixTabbarPositionChanged">
        <body><![CDATA[
          // tabbrowser-tabs constructor reset first tab label to New Tab
          this.tabbrowser.setTabTitle(this.firstChild);
          let position = TabmixSvc.TMPprefs.getIntPref("newTabButton.position");
          if (position != 0)
            gTMPprefObserver.changeNewTabButtonSide(position);

          this.tabbrowser.mTabDropIndicatorBar = this._tabDropIndicator.parentNode;

          // need to add TabScope eventListener
          // need to find a way to do it for all extensions that add event to the tabstrip
          if ("TabScope" in window ) {
            TabScope.uninit();
            TabScope.init();
          }

          this.mTabstrip.setAttribute("flowing", this.getAttribute("flowing"));
          let useTabmixButtons = TabmixTabbar.scrollButtonsMode > TabmixTabbar.SCROLL_BUTTONS_LEFT_RIGHT;
          TabmixTabbar.setScrollButtonBox(useTabmixButtons, true, true);

          // fix incompatibility with Personal Titlebar extension
          // the extensions trigger tabbar binding reset on toolbars customize
          // we need to init our ui settings again
          if (TabmixTabbar._toolboxcustomizeStart) {
            TabmixTabbar.visibleRows = 1;
            TabmixTabbar.updateSettings(false);
            TabmixTabbar._needResetOnCustomizeDone = true;
          }

          // initEvent
          var event = document.createEvent("Events");
          event.initEvent("TabmixTabbarPositionChanged", true, true);
          this.dispatchEvent(event);
        ]]></body>
      </method>

      <method name="_notifyBackgroundTab">
        <parameter name="aTab"/>
        <body><![CDATA[
          if (aTab.pinned)
            return;
          // Is the new tab already completely visible?
          if (this.mTabstrip.isElementVisible(aTab))
            return;

          var scrollRect = this.mTabstrip.scrollClientRect;
          var tab = aTab.getBoundingClientRect();

          if (this.mTabstrip.smoothScroll) {
            let selected = !this.selectedItem.pinned &&
                           this.selectedItem.getBoundingClientRect();

            // Can we make both the new tab and the selected tab completely visible?
            if (!selected ||
                !TabmixTabbar.isMultiRow && Math.max(tab.right - selected.left, selected.right - tab.left) <= scrollRect.width ||
                 TabmixTabbar.isMultiRow && Math.max(tab.bottom - selected.top, selected.bottom - tab.top) <= scrollRect.heigth) {
              this.mTabstrip.ensureElementIsVisible(aTab);
              return;
            }

            if (TabmixTabbar.isMultiRow)
              this.mTabstrip._smoothScrollByPixels(selected.top - scrollRect.top);
            else
              this.mTabstrip._smoothScrollByPixels(this.mTabstrip._isRTLScrollbox ?
                                                 selected.right - scrollRect.right :
                                                 selected.left - scrollRect.left);
          }

          if (!this._animateElement.hasAttribute("notifybgtab")) {
            this._animateElement.setAttribute("notifybgtab", "true");
            setTimeout(function (ele) {
              ele.removeAttribute("notifybgtab");
            }, 150, this._animateElement);
          }
        ]]></body>
      </method>

    </implementation>

    <handlers>
      <handler event="MozMouseHittest" button="0"  phase="capturing"><![CDATA[
        if (event.shiftKey || event.ctrlKey || event.altKey || event.metaKey || event.detail > 0)
          event.stopPropagation();
      ]]></handler>

      <handler event="dblclick" phase="capturing"><![CDATA[
        if (TabmixSvc.TMPprefs.getBoolPref("dblClickTabbar_changesize") &&
            !Tabmix.isPlatform("Mac") && event.target.localName == "tabs") {
          let displayAppButton = !(document.getElementById("titlebar") || document.getElementById("appmenu-toolbar-button")).hidden;
          if (TabsInTitlebar.enabled ||
              (displayAppButton && TabsOnTop.enabled && this.parentNode._dragBindingAlive))
            return;
        }
        TabmixTabClickOptions.onTabBarDblClick(event);
        event.stopPropagation();
        event.preventDefault();
      ]]></handler>

      <handler event="click" phase="capturing"><![CDATA[
        TabmixTabClickOptions.onTabClick(event);
      ]]></handler>

      <handler event="dragstart" phase="capturing"><![CDATA[
        if (!this.tabmix_useDefaultDnD && this.orient == "horizontal")
          TMP_tabDNDObserver.onDragStart(event);
      ]]></handler>

      <handler event="drop" phase="capturing"><![CDATA[
        if (!this.tabmix_useDefaultDnD && this.orient == "horizontal")
          TMP_tabDNDObserver.onDrop(event);
      ]]></handler>

      <handler event="dragend" phase="capturing"><![CDATA[
        if (!this.tabmix_useDefaultDnD && this.orient == "horizontal")
          TMP_tabDNDObserver.onDragEnd(event);
      ]]></handler>

      <handler event="dragexit" phase="capturing"><![CDATA[
        if (!this.tabmix_useDefaultDnD && this.orient == "horizontal")
          TMP_tabDNDObserver.onDragExit(event);
      ]]></handler>
    </handlers>

  </binding>

</bindings>
