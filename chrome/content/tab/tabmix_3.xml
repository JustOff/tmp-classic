<?xml version="1.0"?>

<!DOCTYPE bindings [
<!ENTITY % identityDTD SYSTEM "chrome://tabmixplus/locale/pref-tabmix.dtd" >
%identityDTD;
<!ENTITY % tabmixDTD SYSTEM "chrome://tabmixplus/locale/tabmix.dtd" >
%tabmixDTD;
<!ENTITY % globalDTD SYSTEM "chrome://global/locale/global.dtd">
%globalDTD;
<!ENTITY % tabBrowserDTD SYSTEM "chrome://browser/locale/tabbrowser.dtd" >
%tabBrowserDTD;
]>

<bindings id="tabxbindings_3"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <!--
    Not in use in Firefox 4.0+
    In Firefox 4.0 we add onclick attribute directly to the button
  -->
  <binding id="tabbrowser-close-tab-button"
           extends="chrome://browser/content/tabbrowser.xml#tabbrowser-close-tab-button">
    <handlers>
      <handler event="click" button="1" action="TMP_ClosedTabs.undoCloseTab();"/>
    </handlers>
  </binding>

  <binding id="browser-tab" display="xul:hbox"
        extends="chrome://browser/content/tabbrowser.xml#tabbrowser-tab">
    <content chromedir="&locale.dir;"
             closetabtext="&closeTab.label;">
      <xul:hbox class="tab-image-left tab-startcap tab-left tab-left-border" xbl:inherits="selected,hover"/>
      <xul:hbox class="tab-drag-indicator-left"/>
      <xul:toolbarbutton anonid="tmp-close-button"
                         tabindex="-1" button_side="left"
                         clickthrough="never" class="tab-close-button always-left"/>
      <xul:hbox flex="1" class="tab-middle box-inherit tab-image-middle tab-body" align="center" xbl:inherits="selected">
        <xul:stack class="tab-icon">
          <xul:image class="tab-icon-image" xbl:inherits="validate,src=image" role="presentation"/>
          <xul:image class="tab-protect-icon" />
          <xul:image class="tab-lock-icon"/>
          <xul:image class="tab-reload-icon"/>
        </xul:stack>
        <xul:stack class="tab-text-stack" flex="1">
          <xul:progressmeter class="tab-progress" flex="2" mode="normal"
                             value="0" xbl:inherits="value=tab-progress"/>
          <xul:label class="tab-text"
                           xbl:inherits="value=label,accesskey,crop,disabled"
                           flex="1" role="presentation"/>
          <xul:hbox class="showhover-box">
            <xul:toolbarbutton anonid="tmp-close-button"
                               tabindex="-1" clickthrough="never" class="showhover tabs-closebutton"/>
          </xul:hbox>
        </xul:stack>
      </xul:hbox>
      <xul:toolbarbutton anonid="tmp-close-button"
                         tabindex="-1" button_side="right"
                         clickthrough="never" class="tab-close-button always-right"/>
      <xul:hbox class="tab-drag-indicator-right"/>
      <xul:hbox class="tab-image-right tab-endcap tab-right tab-right-border" xbl:inherits="selected,hover"/>
    </content>

    <implementation>

    <constructor>
      <![CDATA[
        if ("tabmix_inited" in this)
          return;

        if (Tabmix.isVersion(40)) {
          Tabmix.newCode(null, this.doMouseHoverSelect)._replace(
            'document.getBindingParent(aTab.parentNode);',
            'aTab.parentNode.tabbrowser;'
          ).toCode(false, this, "doMouseHoverSelect");
        }

        this.tabmix_inited = true;
      ]]>
    </constructor>
    <field name="mIsHover">
      false
    </field>
    <field name="mButtonId">
      0
    </field>
    <field name="mFocusId">
      0
    </field>
    <field name="mSelect">
      0
    </field>

    <property name="_isProtected" readonly="true">
      <getter><![CDATA[
        return this.hasAttribute("protected") ||
                  (Tabmix.isVersion(40) && this.pinned) ||
                  ("permaTabs" in window && this.hasAttribute("isPermaTab"));
      ]]></getter>
    </property>

    <property name="mouseHoverSelect" readonly="true">
      <getter><![CDATA[
        try {
          return TabmixSvc.prefs.getBoolPref("extensions.tabmix.mouseOverSelect");
        }
        catch(e) {
          return false;
        }
      ]]></getter>
    </property>
    <property name="mouseDownSelect" readonly="true">
      <getter><![CDATA[
        try {
          return TabmixSvc.prefs.getBoolPref("extensions.tabmix.selectTabOnMouseDown");
        }
        catch(e) {
          return false;
        }
      ]]></getter>
    </property>
    <property name="mouseHoverSelectDelay" readonly="true">
      <getter><![CDATA[
        try {
          return TabmixSvc.prefs.getIntPref("extensions.tabmix.mouseOverSelectDelay");
        }
        catch(e) {
          return 250;
        }
      ]]></getter>
    </property>
    <property name="tabXDelay" readonly="true">
      <getter><![CDATA[
        try {
          return TabmixSvc.prefs.getIntPref("extensions.tabmix.tabs.closeButtons.delay");
        }
        catch(e) {
        return 0;
        }
      ]]></getter>
    </property>

    <property name="baseY"
              readonly="true"
              onget="return this.boxObject.y+this.boxObject.height;"/>

    <method name="onMouseOver">
      <parameter name="aEvent"/>
      <body><![CDATA[
        var anonid = aEvent.originalTarget.getAttribute("anonid");
        if (anonid == "tmp-close-button")
          this.mOverCloseButton = true;
        this.mIsHover = true;
        this.mButtonId = window.setTimeout(this.setShowButton, this.tabXDelay, this);
        if (this.mouseHoverSelect)
          this.mFocusId = window.setTimeout(this.doMouseHoverSelect, this.mouseHoverSelectDelay, this);
      ]]></body>
    </method>

    <method name="doMouseHoverSelect">
      <parameter name="aTab"/>
      <body><![CDATA[
        if (!aTab || !aTab.parentNode)
          return; // this tab already removed....

        var b = document.getBindingParent(aTab.parentNode);
        if (b.hasAttribute("preventMouseHoverSelect"))
            b.removeAttribute("preventMouseHoverSelect");
        else if (aTab.mIsHover)
           aTab.parentNode.selectedItem = aTab;
      ]]></body>
    </method>

    <method name="setShowButton">
      <parameter name="aTab"/>
      <body><![CDATA[
        if (!aTab || !aTab.parentNode)
          return; // this tab already removed....

        if ( aTab.mIsHover && aTab.getAttribute("showbutton") != "on")
          aTab.setAttribute("showbutton", "on");
      ]]></body>
    </method>

    <method name="onMouseOut">
      <parameter name="aEvent"/>
      <body><![CDATA[
        var anonid = aEvent.originalTarget.getAttribute("anonid");
        if (anonid == "tmp-close-button")
          this.mOverCloseButton = false;
        this.mIsHover = false;
        clearTimeout(this.mButtonId);
        this.mButtonId = window.setTimeout(this.removeShowButton, this.tabXDelay, this);
        if (this.mouseHoverSelect && this.mFocusId)
          clearTimeout(this.mFocusId);
      ]]></body>
    </method>

    <method name="removeShowButton">
      <parameter name="aTab"/>
      <body><![CDATA[
        if (!aTab || !aTab.parentNode)
          return; // this tab already removed....

        if (!aTab.mIsHover && aTab.hasAttribute("showbutton"))
          aTab.removeAttribute("showbutton");
      ]]></body>
    </method>

    <method name="onMouseCommand">
      <parameter name="aEvent"/>
      <body><![CDATA[
        if ( this == this.parentNode.selectedItem ) {
          this.setAttribute("clickOnCurrent","true");
        }
        // don't allow mouse click with modifiers to select tab
        else if (!aEvent.shiftKey && !aEvent.ctrlKey && !aEvent.altKey && !aEvent.metaKey) {
          this.mSelect = setTimeout(function TMP_onMouseCommand(tab) {
            if (tab.parentNode)
              tab.parentNode._selectNewTab(tab);
          }, 0, this);
        }
      ]]></body>
    </method>

    <method name="clearTimeouts">
      <body><![CDATA[
        let timeouts = ["mSelect", "mFocusId", "mButtonId", "autoReloadTimerID"];
        timeouts.forEach(function(aTimeout) {
          if (aTimeout in this && this[aTimeout]) {
            clearTimeout(this[aTimeout]);
            this[aTimeout] = null;
          }
        }, this);
      ]]></body>
    </method>

    <destructor>
      <![CDATA[
          this.clearTimeouts();
      ]]>
    </destructor>

    </implementation>

    <handlers>
      <handler event="mouseover">
      <![CDATA[
        this.onMouseOver(event);
      ]]>
      </handler>

      <handler event="mouseout">
      <![CDATA[
        this.onMouseOut(event);
      ]]>
      </handler>

      <handler event="mousedown" button="0" phase="capturing">
      <![CDATA[
        if (this.selected) {
          this.style.MozUserFocus = 'ignore';
          this.clientTop; // just using this to flush style updates
        }
        // prevent chrome://global/content/bindings/tabbox.xml#tab mousedown handler
        if (this.mOverCloseButton)
          event.stopPropagation();
        else {
          this.style.MozUserFocus = 'ignore';
          this.clientTop; // just using this to flush style updates
          if (this.mouseDownSelect)
            this.onMouseCommand(event);
          else
            event.stopPropagation();
        }
      ]]>
      </handler>
    </handlers>
  </binding>

  <!-- support for themes that use tabmix_3 -->
  <binding id="scroll-tabs_3"
            extends="chrome://tabmixplus/content/tab/tabbrowser.xml#tabmix-tabbrowser-tabs"/>

  <binding id="tabmix-base-tabbrowser-tabs"
            extends="chrome://browser/content/tabbrowser.xml#tabbrowser-tabs">
    <implementation implements="nsITimerCallback, nsIDOMEventListener">
      <constructor>
        <![CDATA[
          TabmixSvc.prefs.removeObserver("browser.tabs.closeButtons", this._prefObserver);

          if (this.tabmix_inited)
             return;

          // ODFReader change Cc to something else maybe some other extensions do that too !!!
          if ("Cc" in window && Cc != Components.classes)
            Cc = Components.classes;

          if ("Ci" in window && Ci != Components.interfaces)
            Ci = Components.interfaces;

          this.tabmix_inited = true;
          var tabbrowser = Tabmix.isVersion(40) ? this.tabbrowser : document.getBindingParent(this);

          Tabmix.rtl = window.getComputedStyle(tabbrowser, null).direction == "rtl";
          Tabmix.ltr = !Tabmix.rtl;
          Tabmix._rtl50 = Tabmix.isVersion(50) && Tabmix.rtl;

          this._isRTLScrollbox = Tabmix._rtl50 ? false : this.orient != "vertical" && Tabmix.rtl;
          this.setAttribute("closebuttons-side", TabmixSvc.prefs.getBoolPref("extensions.tabmix.tabs.closeButtons.onLeft") ? "left" : "right");
          this._keepLastTab = TabmixSvc.prefs.getBoolPref("extensions.tabmix.keepLastTab");
          this.closeButtonsEnabled = TabmixSvc.prefs.getBoolPref("extensions.tabmix.tabs.closeButtons.enable");
          this.mCloseButtons = TabmixSvc.prefs.getIntPref("extensions.tabmix.tabs.closeButtons");

          /**
           * if we set this in field[s] they will reset each time the tabbar binding construct
           * by tabbar position change
           */
          this.nextTab = 1;
          this._collapsedTabs = 0;
          this._newTabButtonWidth = Tabmix.isVersion(40) ? 22 : 21;

          this.firstChild.setAttribute("flst_id", new Date().getTime());
          this.firstChild.setAttribute("visited", true);
          TabmixTabbar.lockallTabs = TabmixSvc.TMPprefs.getBoolPref("lockallTabs");
          if (TabmixTabbar.lockallTabs)
            this.firstChild.setAttribute("locked", true);

          if (TabmixSvc.TMPprefs.getBoolPref("extraIcons.autoreload"))
            this.setAttribute("extraIcons-autoreload", true);
          if (TabmixSvc.TMPprefs.getBoolPref("extraIcons.protected"))
            this.setAttribute("extraIcons-protected", true);
          if (TabmixSvc.TMPprefs.getBoolPref("extraIcons.locked"))
            this.setAttribute("extraIcons-locked", true);

          if ("linkedBrowser" in this.firstChild)
            tablib.setLoadURIWithFlags(this.firstChild.linkedBrowser);
          /**
           * Session Manager extesion add tabs too soon for us to check isTabVisible properly
           * we get wrong scrollstatus at startup
           * we add flag to use in tabBrowser.tabContainer.isTabVisible
           */
          this.setAttribute("SM_restart", true);

          try {
            Tabmix.beforeStartup(tabbrowser, this);
          } catch (ex) {Tabmix.assert(ex);}
        ]]>
      </constructor>

      <destructor>
        <![CDATA[
          delete this.tabstripInnerbox;
        ]]>
      </destructor>

      <method name="adjustTabstrip">
        <parameter name="skipUpdateScrollStatus"/>
        <parameter name="aUrl"/>
        <body><![CDATA[
          // look at Tabmix.beforeStartup() in setup.js for backward compatibility
          // modes for close button on tabs - extensions.tabmix.tabs.closeButtons
          // 1 - alltabs    = close buttons on all tabs
          // 2 - hovertab   = close buttons on hover tab
          // 3 - activetab  = close button on active tab only
          // 4 - hoveractive = close buttons on hover and active tabs
          // 5 - alltabs wider then  = close buttons on all tabs wider then

          let oldValue = this.getAttribute("closebuttons");
          var tabbrowser = document.getBindingParent(this);
          var tabs = this.childNodes;
          var tabsCount = tabs.length;
          switch (this.closeButtonsEnabled ? this.mCloseButtons : 0) {
          case 0:
            this.removeAttribute("closebuttons-hover");
            this.setAttribute("closebuttons", "noclose");
            break;
          case 1:
            this.removeAttribute("closebuttons-hover");
            this.setAttribute("closebuttons", "alltabs");
            break;
          case 2:
            this.setAttribute("closebuttons-hover", "alltabs");
            this.setAttribute("closebuttons", "noclose");
            break;
          case 3:
          this.removeAttribute("closebuttons-hover");
            this.setAttribute("closebuttons", "activetab");
            break;
          case 4:
            this.setAttribute("closebuttons-hover", "notactivetab");
            this.setAttribute("closebuttons", "activetab");
            break;
          case 5:
            this.removeAttribute("closebuttons-hover");
            if (tabsCount < 2) {
              this.setAttribute("closebuttons", "alltabs");
            }
            else {
              // make sure not to check collapsed tab for width
              // this also work with Firefox pinned tabs
              let tab = this._isRTLScrollbox && !TabmixTabbar.isMultiRow ? this.firstChild : this.lastChild;
              if (tab && tab.getBoundingClientRect().width > this.mTabClipWidth)
                this.setAttribute("closebuttons", "alltabs");
              else
                this.setAttribute("closebuttons", "activetab");
            }
            break;
          }

          /**
           *  Don't use return in this function
           *  TreeStyleTabe add some code at the end
           */
          if (tabsCount == 1) {
            if (this._keepLastTab) {
              this.setAttribute("closebuttons", "noclose");
              this.removeAttribute("closebuttons-hover");
            }
          }
          else if (!skipUpdateScrollStatus && oldValue != this.getAttribute("closebuttons")) {
            TabmixTabbar.updateScrollStatus();
            TabmixTabbar.updateBeforeAndAfter();
          }
        ]]></body>
      </method>

      <property name="overflow">
        <getter><![CDATA[
          return this.hasAttribute("overflow");
        ]]></getter>
        <setter><![CDATA[
          // don't do anything if other extensions set orient to vertical
          // when we arn't use it.
          if (!TabmixTabbar.isMultiRow && this.mTabstrip.orient == "vertical")
            return val;

          if (val != this.overflow) {
            if (val) {
              if (!Tabmix.isVersion(40) && this.getAttribute("flowing") == "singlebar")
                return !val;
              this.setAttribute("overflow", "true");
            }
            else {
              this.removeAttribute("overflow");
            }
            if (Tabmix.isVersion(40))
              Tabmix.setItem("TabsToolbar", "tabstripoverflow", val || null);
          }
          return val;
        ]]></setter>
      </property>

      <!--
        check that we have enough room to show new tab button after the last tab in the current row
        we don't want the button to be on the next row when the tab is on the current row
      -->
      <method name="adjustNewtabButtonvisibility">
        <body><![CDATA[
          if (!TabmixTabbar.isMultiRow && this.mTabstrip.orient == "vertical")
            return;

          if (!this._checkNewtabButtonVisibility) {
            this.disAllowNewtabbutton = this.getAttribute("flowing") == "singlebar" && TabmixSvc.TMPprefs.getBoolPref("newTabButton") &&
                                           TabmixSvc.TMPprefs.getIntPref("newTabButton.position") == 2 && (this.canScrollTabsLeft || this.canScrollTabsRight);
            return;
          }

         var lastTab = this.lastChild;
         // button is visible
         //         A: last tab and the button are in the same row - check if we have room for the button in this row
         //         B: last tab and the button are NOT in the same row  - NG - hide the button
         if (!this.disAllowNewtabbutton) {
           let sameRow = TabmixTabbar.inSameRow(lastTab, this.mTabsNewtabButton);
           if (sameRow) {
             let tabstripEnd = this.mTabstrip.scrollBoxObject.screenX + this.mTabstrip.scrollBoxObject.width;
             let buttonEnd = this.mTabsNewtabButton.boxObject.screenX + this.mTabsNewtabButton.boxObject.width
             this.disAllowNewtabbutton = buttonEnd > tabstripEnd;
           }
           else
             this.disAllowNewtabbutton = true;
           return;
         }
         // button is NOT visible
         //         A: 2 last tabs are in the same row - check if we have room for the button in this row
         //         B: 2 last tabs are NOT in the same row - check if we have room for the last tab + button
         //              after previous to last tab.
         else {
           // ignor the case that this tab width is larger then the tabbar
           let previousTab = lastTab.previousSibling;
           if (!previousTab) {
             this.disAllowNewtabbutton = false;
             return;
           }
           let tsbo = this.mTabstrip.scrollBoxObject;
           let tsboEnd = tsbo.screenX + tsbo.width + (this._rightNewTabButton ? this._rightNewTabButton.boxObject.width: 0);
           if (TabmixTabbar.inSameRow(lastTab, previousTab)) {
             let buttonEnd = lastTab.boxObject.screenX + lastTab.boxObject.width + this._newTabButtonWidth;
             this.disAllowNewtabbutton = buttonEnd > tsboEnd;
             return;
           }
           else {
             let lastTabEnd = previousTab.boxObject.screenX + previousTab.boxObject.width
                                         + lastTab.boxObject.width;
             // both last tab and new tab button are in the next row
             if (lastTabEnd > tsboEnd)
               this.disAllowNewtabbutton = false;
             else
               this.disAllowNewtabbutton = lastTabEnd + this._newTabButtonWidth > tsboEnd;
             return;
           }
         }
        ]]></body>
      </method>

      <property name="maxRow" readonly="true">
        <getter><![CDATA[
          var row = TabmixSvc.prefs.getIntPref("extensions.tabmix.tabBarMaxRow");
          Tabmix.setItem(this.mTabstrip._scrollButtonDown, "notonbottom", (row > 2) || null);
          return row;
        ]]></getter>
      </property>

      <property name="topTabY" readonly="true">
        <getter><![CDATA[
          return this.tabstripInnerbox.boxObject.y + Tabmix.getStyle(this.tabstripInnerbox, "paddingTop");
        ]]></getter>
      </property>

      <method name="getTabRowNumber">
        <parameter name="aTab"/>
        <parameter name="aTop"/>
        <body><![CDATA[
          var height = aTab ? aTab.boxObject.height : 0;
          if (height == 0) // don't panic
            return;
          // some theme add marginTop/marginBottom to tabs
          var cStyle = window.getComputedStyle(aTab, null);
          var marginTop = parseInt(cStyle["marginTop"]) || 0;
          var marginBottom = parseInt(cStyle["marginBottom"]) || 0;
          height += marginTop + marginBottom;

          var tabBottom = aTab.boxObject.y - marginTop + height
          return Math.round((tabBottom - aTop)/height);
        ]]></body>
      </method>

    </implementation>
  </binding>

  <binding id="tabmix-scroll-button"
      extends="chrome://global/content/bindings/toolbarbutton.xml#toolbarbutton-image">

    <implementation implements="nsITimerCallback, nsIDOMEventListener">
      <constructor><![CDATA[
        try {
          this._scrollDelay =
             TabmixSvc.prefs.getIntPref("extensions.tabmix.clickToScroll.scrollDelay");
        }
        catch (ex) {      }

        this.tabContainer = document.getBindingParent(this);
        if (this.tabContainer.localName == "arrowscrollbox")
          this.tabContainer = document.getBindingParent(this.tabContainer);

        this._scrollIndex = this.getAttribute("scrollIndex") == "1" ? 1 : -1;
        this._side = this._scrollIndex == 1 ? "right" : "left";
      ]]></constructor>

      <destructor><![CDATA[
        // Release timer to avoid reference cycles.
        if (this._scrollTimer) {
          this._scrollTimer.cancel();
          this._scrollTimer = null;
        }
        this.tabContainer = null;
        document.removeEventListener("mouseup", this, false);
        document.removeEventListener("blur", this, true);
      ]]></destructor>

      <field name="_scrollIndex">0</field>
      <field name="_scrollDelay">150</field>

      <method name="notify">
        <parameter name="aTimer"/>
        <body>
        <![CDATA[
          if (this.hasAttribute("disabled")) {
            this._stopScroll();
            return;
          }

          if (!document)
            aTimer.cancel();

          this.tabContainer.tabsScroll(this._scrollIndex);
        ]]>
        </body>
      </method>

      <method name="_startScroll">
        <body><![CDATA[
          if (this.hasAttribute("disabled")) {
            this._stopScroll();
            return;
          }
          var scrollDelay = this._scrollDelay;
          if (!this._scrollTimer)
            this._scrollTimer =
              Components.classes["@mozilla.org/timer;1"]
                        .createInstance(Components.interfaces.nsITimer);
          else
            this._scrollTimer.cancel();

          this._scrollTimer.initWithCallback(this, scrollDelay,
                                             this._scrollTimer.TYPE_REPEATING_SLACK);
          this.notify(this._scrollTimer);
          this._mousedown = true;
        ]]>
        </body>
      </method>

      <method name="_stopScroll">
        <body><![CDATA[
          if (this._scrollTimer)
            this._scrollTimer.cancel();
          this._mousedown = false;
        ]]></body>
      </method>

      <method name="_pauseScroll">
        <body><![CDATA[
          if (this._mousedown) {
            this._stopScroll();
            this._mousedown = true;
            document.addEventListener("mouseup", this, false);
            document.addEventListener("blur", this, true);
          }
        ]]></body>
      </method>

      <method name="_continueScroll">
        <body><![CDATA[
          if (this._mousedown)
            this._startScroll();
        ]]></body>
      </method>

      <method name="handleEvent">
        <parameter name="aEvent"/>
        <body><![CDATA[
          if (aEvent.type == "mouseup" ||
              aEvent.type == "blur" && aEvent.target == document) {
            this._mousedown = false;
            document.removeEventListener("mouseup", this, false);
            document.removeEventListener("blur", this, true);
          }
        ]]></body>
      </method>
    </implementation>

    <handlers>
      <handler event="mousedown" button="0" phase="capturing">
        _startScroll();
      </handler>
      <handler event="mouseover" button="0" phase="capturing">
        _continueScroll();
      </handler>
      <handler event="mouseup" button="0" phase="capturing">
        _stopScroll();
      </handler>
      <handler event="mouseout" button="0" phase="capturing">
        _pauseScroll();
      </handler>
      <handler event="contextmenu">
        TabmixAllTabs.createScrollButtonTabsList(event, this._side);
      </handler>
      <handler event="dblclick" button="0" phase="capturing">
        event.stopPropagation();
      </handler>
    </handlers>

  </binding>

  <!--
      we don't use this for Firefox 3.0 +
      we leave it here because some theme looking for this
   -->
  <binding id="tabbrowser"
      extends="chrome://browser/content/tabbrowser.xml#tabbrowser">

    <implementation>

    </implementation>

  </binding>

</bindings>
